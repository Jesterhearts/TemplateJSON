#include <iostream>
#include <sstream>
#include <string>
#include <stdexcept>

/* Helper macros */
#define WIDEN(STRING)   \
    L ## STRING

#define EXPAND_MACRO_WIDEN_IMPL(MACRO)  \
    WIDEN( #MACRO)

#define EXPAND_MACRO_WIDEN(MACRO) \
    EXPAND_MACRO_WIDEN_IMPL(MACRO)

/* Don't put this anywhere in your class definition unless you like reading horrific template errors */
#define JSON_VAR_DECORATOR \
    static constexpr JSON::__json_var

/* constructor macros */
#define JSON_CLASS_IMPL(CLASS_NAME, CLASS_BODY)                                                 \
    class CLASS_NAME {                                                                          \
        /* inject the stuff that we need to function. It shouldn't be public */                 \
        /* This gives us the string for the class that we parse at compile time */              \
        static constexpr const wchar_t* __##CLASS_NAME = WIDEN(#CLASS_BODY);                    \
                                                                                                \
        /* This is the base template from which all variables will make their specializations   \
           uniqueID is generated by the __COUNTER__ macro and identifies each member of the     \
           class                                                                                \
         */                                                                                     \
        template<class ThisClass, int uniqueID>                                                 \
        static void VarToJSON(ThisClass&, JSON::VarToJSONIdentifier<uniqueID>);                 \
        /* Here we actually make the rest of the class for them */                              \
        CLASS_BODY                                                                              \
    };

/* Do indirection so macros in the class body get invoked properly */
#define JSON_CLASS(CLASS_NAME, CLASS_BODY)  \
    JSON_CLASS_IMPL(CLASS_NAME, CLASS_BODY)

#define JSON_VAR_IMPL(CLASS, TYPE, VARNAME, KEY)                                    \
    /* This is the thing our tokenizer looks for, KEY gives it the ID for the       \
       specialization.                                                              \
     */                                                                             \
    JSON_VAR_DECORATOR __##VARNAME##KEY = nullptr;                                  \
                                                                                    \
    /* This function does the actual work */                                        \
    template<class ThisClass>                                                       \
    static void VarToJSON(ThisClass& classFrom,                                     \
                          JSON::VarToJSONIdentifier<KEY> helper) {                  \
      /* stringmap.append = jsonValueParserForTYPE :: parse(classFrom.VARNAME) */   \
                                                                                    \
    }                                                                               \
    TYPE VARNAME;

/* Indirection here so that KEY_ARG (__COUNTER__) will become a number */
#define JSON_VAR_HELPER(CLASS, TYPE, VARNAME, KEY_ARG)  \
    JSON_VAR_IMPL(CLASS, TYPE, VARNAME, KEY_ARG)

/* Make a variable and give it a unique ID */
#define JSON_VAR(CLASS, TYPE, VARNAME)  \
    JSON_VAR_HELPER(CLASS, TYPE, VARNAME, __COUNTER__)

/* holy shit so many templates */
namespace JSON {
    /* Important constants used in parsing */

    //The decorator
    //  - typedef lets us use it in class defs and still find the unique string
    typedef const void* __json_var;

    //This is used to match against when searching the stringy class.
    // It's defined in terms of what we use to make the identifier, so hopefully
    //  it doesn't break everytime we change things
    constexpr const wchar_t* DECORATOR_STR = EXPAND_MACRO_WIDEN(JSON_VAR_DECORATOR);

    /* Helpers for the template programs */
    template<int uniqueID>
    struct VarToJSONIdentifier {
        const static int help = uniqueID;
    };

    template<wchar_t testChar,
             wchar_t candidateChar>
    struct JSONTokenTester {
        static constexpr bool Equal() {
            return testChar == candidateChar;
        }

        static constexpr bool NotEqual() {
            return testChar != candidateChar;
        }
    };

////////////////////////////////////////////////////////////////////////////////
// JSONIsNullOrWhitespace implementation
////
    template<wchar_t testChar>
    struct JSONIsNullOrWhitespace {
        static constexpr bool Check() {
            /* The specializations do the check for valid chars
               so if it hits this it can't be
             */
            return false;
        }
    };

    template<>
    struct JSONIsNullOrWhitespace<L' '> {
        static constexpr bool Check() {
            return true;
        }
    };

    template<>
    struct JSONIsNullOrWhitespace<L'\t'> {
        static constexpr bool Check() {
            return true;
        }
    };

    template<>
    struct JSONIsNullOrWhitespace<L'\0'> {
        static constexpr bool Check() {
            return true;
        }
    };

////////////////////////////////////////////////////////////////////////////////
// JSONIsNumber implementation
////
    template<wchar_t testChar>
    struct JSONIsNumber {
        static constexpr bool Check() {
            /* The specializations enumerate 0-9
               so if it hits this it can't be
             */
            return false;
        }
    };

    template<>
    struct JSONIsNumber<L'0'> {
        static constexpr bool Check() {
            return true;
        }
    };

    template<>
    struct JSONIsNumber<L'1'> {
        static constexpr bool Check() {
            return true;
        }
    };

    template<>
    struct JSONIsNumber<L'2'> {
        static constexpr bool Check() {
            return true;
        }
    };

    template<>
    struct JSONIsNumber<L'3'> {
        static constexpr bool Check() {
            return true;
        }
    };

    template<>
    struct JSONIsNumber<L'4'> {
        static constexpr bool Check() {
            return true;
        }
    };

    template<>
    struct JSONIsNumber<L'5'> {
        static constexpr bool Check() {
            return true;
        }
    };

    template<>
    struct JSONIsNumber<L'6'> {
        static constexpr bool Check() {
            return true;
        }
    };

    template<>
    struct JSONIsNumber<L'7'> {
        static constexpr bool Check() {
            return true;
        }
    };

    template<>
    struct JSONIsNumber<L'8'> {
        static constexpr bool Check() {
            return true;
        }
    };

    template<>
    struct JSONIsNumber<L'9'> {
        static constexpr bool Check() {
            return true;
        }
    };

////////////////////////////////////////////////////////////////////////////////
// JSONCharToInt implementation
////
    template <wchar_t Char>
    struct JSONCharToInt {
        static constexpr int Value();
    };

    template<>
    struct JSONCharToInt<L'0'> {
        static constexpr int Value() {
            return 0;
        }
    };

    template<>
    struct JSONCharToInt<L'1'> {
        static constexpr int Value() {
            return 1;
        }
    };

    template<>
    struct JSONCharToInt<L'2'> {
        static constexpr int Value() {
            return 2;
        }
    };

    template<>
    struct JSONCharToInt<L'3'> {
        static constexpr int Value() {
            return 3;
        }
    };

    template<>
    struct JSONCharToInt<L'4'> {
        static constexpr int Value() {
            return 4;
        }
    };

    template<>
    struct JSONCharToInt<L'5'> {
        static constexpr int Value() {
            return 5;
        }
    };

    template<>
    struct JSONCharToInt<L'6'> {
        static constexpr int Value() {
            return 6;
        }
    };

    template<>
    struct JSONCharToInt<L'7'> {
        static constexpr int Value() {
            return 7;
        }
    };

    template<>
    struct JSONCharToInt<L'8'> {
        static constexpr int Value() {
            return 8;
        }
    };

    template<>
    struct JSONCharToInt<L'9'> {
        static constexpr int Value() {
            return 9;
        }
    };

////////////////////////////////////////////////////////////////////////////////
// JSONParseInt implementation
////
    template<const wchar_t *const *string,
             size_t offset = 0,
             int value = 0,
             bool endOfString = false>
    struct JSONParseInt {
        static constexpr int Parse() {
            return JSONParseInt<string,
                                offset + 1,
                                value * 10 + JSONCharToInt<string[0][offset]>::Value(),
                                !JSONIsNumber<string[0][offset + 1]>::Check()
                               >::Parse();
        }
    };

    template<const wchar_t *const *string,
             size_t offset,
             int value>
    struct JSONParseInt<string,
                        offset,
                        value,
                        true> {
        static constexpr int Parse() {
            return value;
        }
    };

////////////////////////////////////////////////////////////////////////////////
// JSONWhitespaceCounter implementation
////
    template<const wchar_t* const* word,
             size_t offset,
             size_t count = 0,
             bool matchSpaceFailed = false,
             bool matchTabFailed = false>
    struct JSONWhitespaceCounter {
        static constexpr size_t Count() {
            return JSONWhitespaceCounter<word,
                                         offset + 1,
                                         count + 1,
                                         JSONTokenTester<word[0][offset],
                                                         L' '
                                                        >::NotEqual(),
                                         JSONTokenTester<word[0][offset],
                                                         L'\t'
                                                        >::NotEqual()
                                        >::Count();
        }
    };

    template<const wchar_t* const* word,
             size_t offset,
             size_t count>
    struct JSONWhitespaceCounter<word,
                               offset,
                               count,
                               true,
                               true> {
        static constexpr size_t Count() {
            /* We counted one extra to get here */
            return count - 1;
        }
    };

////////////////////////////////////////////////////////////////////////////////
// JSONTokenMatcherPart implementation
////
    //This case handles successful comparisons and recurses
    template<const wchar_t* const* candidateWord,
             const wchar_t* const* testWord,
             size_t candidateOffset,
             size_t testOffset = 0,
             bool matchFailed = false,
             bool endCandidateWord = false,
             bool endTestWord = false>
    struct JSONTokenMatcherPart { 
        static constexpr bool MatchToken() {
            return JSONTokenMatcherPart<candidateWord,
                                        testWord,
                                        candidateOffset + 1,
                                        testOffset + 1,
                                        JSONTokenTester<testWord[0][testOffset],
                                                        candidateWord[0][candidateOffset]
                                                       >::NotEqual(),
                                        JSONTokenTester<candidateWord[0][candidateOffset + 1],
                                                        L'\0'
                                                       >::Equal(),
                                        JSONTokenTester<testWord[0][testOffset + 1],
                                                        L'\0'
                                                       >::Equal()
                                       >::MatchToken();
        }
    };

    //This is the fail case, no need to continue
    template<const wchar_t* const* candidateWord,
             const wchar_t* const* testWord,
             size_t candidateOffset,
             size_t testOffset,
             bool endCandidateWord,
             bool endTestWord>
    struct JSONTokenMatcherPart<candidateWord,
                                testWord,
                                candidateOffset,
                                testOffset,
                                /* matchFailed */ true,
                                endCandidateWord,
                                endTestWord> {
        static constexpr bool MatchToken() {
            return false;
        }
    };

    //The string isn't long enough
    template<const wchar_t* const* candidateWord,
             const wchar_t* const* testWord,
             size_t candidateOffset,
             size_t testOffset,
             bool matchFailed,
             bool endTestWord>
    struct JSONTokenMatcherPart<candidateWord,
                                testWord,
                                candidateOffset,
                                testOffset,
                                matchFailed,
                                /* endCandidateWord */ true,
                                endTestWord> {
        static constexpr bool MatchToken() {
            return false;
        }
    };

    //Also not long enough, also it didn't match
    template<const wchar_t* const* candidateWord,
             const wchar_t* const* testWord,
             size_t candidateOffset,
             size_t testOffset,
             bool endTestWord>
    struct JSONTokenMatcherPart<candidateWord,
                                testWord,
                                candidateOffset,
                                testOffset,
                                /* matchFailed */ true,
                                /* endCandidateWord */ true,
                                endTestWord> {
        static constexpr bool MatchToken() {
            return false;
        }
    };

    //YAY! A Match!
    template<const wchar_t* const* candidateWord,
             const wchar_t* const* testWord,
             size_t candidateOffset,
             size_t testOffset,
             bool matchFailed,
             bool endCandidateWord>
    struct JSONTokenMatcherPart<candidateWord,
                                testWord,
                                candidateOffset,
                                testOffset,
                                matchFailed,
                                endCandidateWord,
                                /* endTestWord */ true> {
        static constexpr bool MatchToken() {
            return true;
        }
    };

    //Also a match, but full length
    template<const wchar_t* const* candidateWord,
             const wchar_t* const* testWord,
             size_t candidateOffset,
             size_t testOffset,
             bool matchFailed>
    struct JSONTokenMatcherPart<candidateWord,
                                testWord,
                                candidateOffset,
                                testOffset,
                                matchFailed,
                                /* endCandidateWord */ true,
                                /* endTestWord */ true> {
        static constexpr bool MatchToken() {
            return true;
        }
    };

////////////////////////////////////////////////////////////////////////////////
// JSONTagMatcher implementation
////
    //This class checks if a string at an offset matches the decorator
    template<const wchar_t *const *classInfo,
             unsigned int offset>
    struct JSONTagMatcher {
        static constexpr bool MatchJSONVarTag() {
            return JSONTokenMatcherPart<classInfo,
                                        &DECORATOR_STR,
                                        offset
                                       >::MatchToken();
        }
    };

////////////////////////////////////////////////////////////////////////////////
// JSONClassParserTokenFinder implementation
////
    //This recursively searches the input string until it finds a matching token
    //  or fails to find one
    template<const wchar_t *const *classInfo,
             unsigned int offset,
             bool foundToken,
             bool endOfInput>
    struct JSONClassParserTokenFinder {
        static constexpr const size_t FindJSONToken() {
            return JSONClassParserTokenFinder<classInfo,
                                              offset + 1,
                                              JSONTagMatcher<classInfo,
                                                             offset
                                                            >::MatchJSONVarTag(),
                                              classInfo[0][offset + 1] != L'\0'
                                             >::FindJSONToken();
        }
    };

    //This is the termination case when a recursive search finds a token
    template<const wchar_t *const *classInfo,
             unsigned int offset,
             bool endOfInput>
    struct JSONClassParserTokenFinder<classInfo,
                                      offset,
                                      /* foundToken*/ true,
                                      endOfInput> {
        static constexpr size_t FindJSONToken() {
            //The offset is increased before we know if we found the end, so we
            //  need to decrease it here to get the real offset
            return offset - 1;
        }
    };

    //Also a termination case
    template<const wchar_t *const *classInfo,
             unsigned int offset>
    struct JSONClassParserTokenFinder<classInfo,
                                      offset,
                                      /* foundToken*/ true,
                                      /* endOfInput */ false> {
        static constexpr size_t FindJSONToken() {
            //The offset is increased before we know if we found the end, so we
            //  need to decrease it here to get the real offset
            return offset - 1;
        }
    };

    //This handles the recursive search failing to locate a token 
    template<const wchar_t *const *classInfo,
             unsigned int offset,
             bool foundToken>
    struct JSONClassParserTokenFinder<classInfo,
                                      offset,
                                      foundToken,
                                      /* endOfInput */ false> {
        static constexpr const size_t FindJSONToken() {
            return offset - 1;
        }
    };

////////////////////////////////////////////////////////////////////////////////
// JSONVarIDParser implementation
////
    //This eats tokens until the start of a number is found
    //  or the string ends
    template<const wchar_t *const *variableString,
             size_t offset = 0,
             bool startOfNumber = false,
             bool numberFound = false,
             bool endOfVariable = false>
    struct JSONVarIDParser {
        static constexpr int Parse() {
            return JSONVarIDParser<variableString,
                                   offset + 1,
                                   JSONIsNumber<variableString[0][offset]
                                               >::Check(),
                                   numberFound,
                                   JSONIsNullOrWhitespace<variableString[0][offset]
                                                         >::Check()
                                  >::Parse();
        }
    };

    template<const wchar_t *const *variableString,
             size_t offset,
             bool startOfNumber,
             bool endOfVariable>
    struct JSONVarIDParser<variableString,
                           offset,
                           startOfNumber,
                           /* numberFound */ true,
                           endOfVariable> {
        static constexpr int Parse() {
            return JSONParseInt<variableString + offset>::Parse();
        }
    };

////////////////////////////////////////////////////////////////////////////////
// JSONVarFnInvoker implementation
////
    template<class classOn,
             const wchar_t * variableString>
    struct JSONVarFnInvoker {
    };

////////////////////////////////////////////////////////////////////////////////
// JSONClassParser implementation
////
    template<const wchar_t *const *classInfo>
    struct JSONClassParser {
        static constexpr const size_t FindNextJSONToken() {
            return JSONClassParserTokenFinder<classInfo, 0, false, true>::FindJSONToken();
        }
    };

    constexpr const wchar_t* test = L"10";

    template<const wchar_t *const *classInfo>
    struct JSONParser {
        static void FromJSON() {
            // bool t = JSONTagMatcher<classInfo, 0, true>::MatchJSONVarTag();
            // std::wcout << t << std::endl;
            std::wcout << L"Class info:" << std::endl;
            std::wcout << *classInfo << std::endl;
            std::wcout << L"Decorator:" << std::endl;
            std::wcout << DECORATOR_STR << std::endl << std::endl;

            std::wcout << L"Result:" << std::endl;
            size_t first_pos = JSONClassParser<classInfo>::FindNextJSONToken();
            std::wcout << &(*classInfo)[first_pos] << std::endl;

            std::wcout << JSONParseInt<&test>::Parse() << std::endl;
        }
    };

    template<class Type>
    struct JSONValuePODParser {
        static Type FromJSON(const std::wstring& json) {
            std::wstringstream wss;
            wss << json;

            Type value;
            wss >> value;

            if(wss.fail()) {
                throw std::invalid_argument("bad json value for key"); 
            }

            return value;
        }
    };
}

JSON_CLASS(Test, 
public:
     JSON_VAR(Test, int, __json);
);

int main() {

    JSON::JSONParser<&Test::__Test>::FromJSON();

    return 0;
}
